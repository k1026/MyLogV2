# セルタイトル推定仕様

## 1. 概要
ユーザーが新しいセルを追加する際、次に入力される可能性が高いセルタイトルを推定して自動的に入力補完候補する機能の仕様です。
「直近のセルタイトル(10件)」、「現在の時刻」、「現在の位置情報」という**3つの文脈（コンテキスト）**を考慮し、次にくるセルタイトルをスコアリングして推定します。

## 2. アルゴリズム
**「重み付け投票（Weighted Voting）」**を採用します。
「直近のセルタイトル」「時間」「場所」それぞれの**出現確率**に**信頼度**（重み）を掛けて合計し、最もスコアが高いものを候補とします。

### 2.1 概念（スコア計算式）
ある候補タイトルT のスコア S(T) は以下の合算で求めます。

S(T) = (W_seq \times P_seq) + (W_time \times P_time) + (W_loc \times P_loc)

- P_seq: 文脈（直近10件）から見た、そのタイトルが出る確率
- P_time: 現在時刻から見た、そのタイトルが出る確率
- P_loc: 現在地から見た、そのタイトルが出る確率
- W: 各要素の重要度（重み係数）

### 2.2 データ構造（学習データ）
巨大な連鎖マップを持つのではなく、**特徴ごとの出現回数マップ（Feature Maps）**を3種類持ちます。
1. Sequence Map (遷移頻度)
- Key: PrevTitle
- Value: Map<NextTitle, Count>
※これを直近1つ前だけでなく、2つ前、3つ前...のデータも保持するか、あるいは推定時に直近N個分を「直前」として検索にかけます。

2. Time Map (時間別頻度)
- Key: TimeSlot (例: "09", "18" などの時間のバケット)
- Value: Map<Title, Count>

3. Location Map (場所別頻度)
- Key: GeoHash (例: 100m単位で丸められた緯度経度グリッド)
- Value: Map<Title, Count>

### 2.3 推定ロジックの詳細
新しいセルを追加するタイミングで、以下の手順で計算します。

#### Step 1: 現在の状況（クエリ）を取得
- 履歴: DB上の直近10個のタイトルリスト ※CardセルとTimeセルは除外
- 時間: 現在の「時」（例: 14時）
- 場所: 現在の緯度経度を100m四方のエリアIDに変換（プライバシー保護とデータ疎化のため）

#### Step 2: 投票（スコアリング）
保存されている全タイトル候補に対して、以下のポイントを加算します。

1. 文脈スコア（履歴からの推測）
直近1つ前、2つ前...のタイトルを見て、そこから遷移する可能性を加算します。ただし、近い過去ほど重視します。
 $t_{-1}$ （1つ前）の次にそのタイトルが来た回数 × 1.0
 $t_{-2}$ （2つ前）の次にそのタイトルが来た回数 × 0.5
...
 $t_{-10}$ （10つ前）の次にそのタイトルが来た回数 × 0.1

2. 時間スコア（生活リズムからの推測）
「今の時間帯（例: 朝8時）」にそのタイトルが使われた回数 × 時間重み係数
    - 例: 朝8時は「朝食」「通勤」などのスコアが高くなる

3. 場所スコア（場所からの推測）
「今のエリア（例: 自宅エリア）」でそのタイトルが使われた回数 × 場所重み係数
    - 例: ジムのエリアでは「筋トレ」、会社のエリアでは「会議」のスコアが高くなる
#### Step 3: 結果出力
合計スコアが高い順にソートし、上位数件をサジェスト候補として返します。

### 2.4 軽量化・高速化の工夫
このモデルは「10件前まで見る」などで計算量が増える懸念がありますが、以下の工夫で軽量に動作させます。

- **インデックスの逆引き**:毎回全タイトルを計算するのではなく、**「現在の文脈（直前の単語、今の時間、今の場所）に出現実績があるタイトル」**だけを計算対象（ショートリスト）にします。

- **時間のバケット化（Binning）**:「14:32」のように分単位で保存せず、「14時台」や「朝・昼・晩」のように大まかに丸めて保存し、データの分散（スパース化）を防ぎます。

- **場所のグリッド化（Geohash / Rounding）**:緯度経度を小数点以下3桁程度（約100m精度）で丸めてキーにします。これにより「同じ建物内」を同一の場所として扱え、データ検索がO(1)で済みます。

## 3. データ構造 (In-Memory / Storage)
推定に必要な学習データは、以下の3つのマップ構造として保持・永続化されます。

### 3.1 Transition Map (遷移頻度)
「あるタイトルの次に何が来たか」を記録します。

Key: PrevTitle, Value: { NextTitle: Count }
type TransitionMap = Record<string, Record<string, number>>;

### 3.2 Time Map (時間別頻度)
「何時にどのタイトルが作られたか」を記録します。

Key: Hour(0-23), Value: { Title: Count }
type TimeMap = Record<number, Record<string, number>>;

### 3.3 Location Map (場所別頻度)
「どこでどのタイトルが作られたか」を記録します。 キーには丸められた緯度経度文字列（GeoKey）を使用します。

Key: "Lat_Lon", Value: { Title: Count }
type LocationMap = Record<string, Record<string, number>>;

### 3.4 Storage
ブラウザのローカルストレージに保存し、アプリ起動時に読み込み即座に使用できるようにします。
アプリ起動後にバックグラウンドでDBを使用して学習データの更新を行います。この時過去の学習データを削除せずに追加で学習する形を取り、学習にはDBの全てのデータを使用せずに直近3000件までものを優先して利用し集計・更新します。

## 4. 処理フロー
### 4.1 初期化プロセス（起動時）
1. Load: localStorage から直近の学習済みJSONデータを読み込み、メモリ上に展開します。
2. Estimate Ready: ユーザーはこの時点で即座に推定機能を利用可能です。
3. Async Update: バックグラウンド（Web Worker等）でDBから最新のセルデータを取得し、上記3つのMapを再集計・更新します。

### 4.2 推定実行プロセス（入力時）
セルの追加タイミングで使用。

1. Context取得:
- History: DB上の直近10個のセルタイトルを取得。※CardセルとTimeセルは除外
- Now: 現在時刻（時）。
- Geo: 現在のGPS座標を取得し、GeoKeyに変換。

2. Candidates抽出:
- Transition Map等から、関連する全てのタイトル候補をリストアップします。

3. Scoring:
- 各候補に対して 2.1 の式に基づきスコアを計算します。

4. Sort & Filter:
- スコア降順にソートし、上位5件を返却します。

5. 詳細仕様・制約
・ 減衰係数の設定 (Decay Factor)
- 履歴の影響力は指数関数的に減衰させます。
$k=1$ (1つ前): 1.0
$k=2$ (2つ前): 0.8
$k=3$ (3つ前): 0.6
...

$k >= 5$: 0.1 (わずかな加点のみ)

・ パフォーマンス要件
- 計算時間: メインスレッドで 10ms 以内に完了すること。
- メモリ: 学習データ全体で 1MB を超えないよう、古いデータは保存時に枝刈り（Pruning）を行う。